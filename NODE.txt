***NODE*******************
AHT10 (I²C)
AHT10	ESP32-C3 SuperMini
VCC	3.3 V
GND	GND
SDA	GPIO 8
SCL	GPIO 9

HX711 → ESP32-C3 SuperMini
HX711	ESP32-C3 SuperMini
VCC	5V
GND	GND
DT	GPIO 3
SCK	GPIO 1

RFM95 (SPI)
RFM95	ESP32-C3 SuperMini
VCC	3.3 V
GND	GND
SCK	GPIO 4
MISO	GPIO 5
MOSI	GPIO 6
NSS	GPIO 7
RST	GPIO 10
DIO0	GPIO 2

*************************
#include <Wire.h>
#include <Adafruit_AHTX0.h>
#include <SPI.h>
#include <RH_RF95.h>
#include "HX711.h"

/* ================= I2C ================= */
#define SDA_PIN 8
#define SCL_PIN 9

/* ================= HX711 ================= */
#define HX_DOUT 3
#define HX_SCK  1
HX711 scale;

/* ================= LoRa ================= */
#define RFM95_CS   7
#define RFM95_RST  10
#define RFM95_INT  2
#define RFM95_FREQ 868.0

/* ================= Objects ================= */
Adafruit_AHTX0 aht;
RH_RF95 rf95(RFM95_CS, RFM95_INT);

uint32_t counter = 0;

void setup() {
  Serial.begin(115200);
  delay(2000);

  Serial.println();
  Serial.println("=== FULL NODE DIAGNOSTIC (AHT10 + HX711 + LoRa) ===");

  /* -------- I2C / AHT10 -------- */
  Wire.begin(SDA_PIN, SCL_PIN);

  if (!aht.begin()) {
    Serial.println("ERROR: AHT10 not detected");
    while (1);
  }
  Serial.println("AHT10 OK");

  /* -------- HX711 -------- */
  scale.begin(HX_DOUT, HX_SCK);

  Serial.print("Waiting for HX711");
  uint32_t start = millis();
  while (!scale.is_ready()) {
    Serial.print(".");
    delay(100);

    if (millis() - start > 3000) {
      Serial.println("\nERROR: HX711 timeout");
      break;
    }
  }

  if (scale.is_ready()) {
    Serial.println("\nHX711 READY");
  } else {
    Serial.println("\nHX711 NOT READY (continuing anyway)");
  }

  /* -------- RFM95 -------- */
  pinMode(RFM95_RST, OUTPUT);
  digitalWrite(RFM95_RST, HIGH);
  digitalWrite(RFM95_RST, LOW);
  delay(10);
  digitalWrite(RFM95_RST, HIGH);
  delay(10);

  if (!rf95.init()) {
    Serial.println("ERROR: RFM95 init failed");
    while (1);
  }

  rf95.setFrequency(RFM95_FREQ);
  rf95.setTxPower(14, false);

  Serial.println("RFM95 OK");
  Serial.println("==============================================");
}

void loop() {
  /* -------- AHT10 -------- */
  sensors_event_t humidity, temperature;
  aht.getEvent(&humidity, &temperature);

  float t = temperature.temperature;
  float h = humidity.relative_humidity;

  /* -------- HX711 -------- */
  long raw_weight = 0;
  bool hx_ok = false;

  if (scale.is_ready()) {
    raw_weight = scale.read_average(5);
    hx_ok = true;
  }

  /* -------- Payload -------- */
  char payload[128];
  snprintf(payload, sizeof(payload),
           "T=%.2fC H=%.1f%% W=%ld HX=%d #%lu",
           t, h, raw_weight, hx_ok, counter++);

  Serial.println(payload);

  rf95.send((uint8_t*)payload, strlen(payload));
  rf95.waitPacketSent();

  delay(5000);
}





***GATEWAY******************************
Zapojenie RFM95 ↔ ESP32-C3 SuperMini

SPI zapojenie
RFM95	ESP32-C3 SuperMini
VCC	3.3 V
GND	GND
SCK	GPIO4
MISO	GPIO5
MOSI	GPIO6
NSS (CS)	GPIO7
RST	GPI10
DIO0	GPIO3

****************************************
const char* WIFI_SSID = "T-A81MJA";
const char* WIFI_PASS = "t2lmlakb8kbv";
const char* SERVER_HOST = "ebeehive.vercel.app"; // no protocol, no trailing slash
const char* HIVE_ID = "HIVE-017";                 // target hive id (HIVE-xxx)
const char* ESP32_API_KEY = "";   

